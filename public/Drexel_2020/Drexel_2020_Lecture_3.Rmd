---
title: "Lecture 3"
subtitle: "Data manipulation"
author: "Jung-Jin Lee"
date: "Jan 21, 2020"
output:
  xaringan::moon_reader:
    css: ["default", "default-fonts", "Drexel.css"] 
    lib_dir: libs
    nature:
      highlightStyle: github
      highlightLines: true
      countIncrementalSlides: false
editor_options: 
  chunk_output_type: console
---
 
```{r, message = F, echo = F, warning = F}
library(tidyverse) 
library(knitr) 
opts_chunk$set(
  tidy = FALSE,
  cache = FALSE,
  echo = TRUE,
  warning = FALSE,
  message = FALSE,
  dpi = 300,
  fig.align = "center",
  fig.width = 4,
  fig.height = 4
  )
filter <- dplyr::filter
options(width = 70) # controls console (and slide) output width
```

## Exploring data

```{r}
d <- iris # iris data set comes with base R
dim(d)
```

So `d` has `r nrow(d)` observations and `r ncol(d)` variables.

```{r}
head(d)
```

---

## Exploring data, continued

```{r}
table(d$Species)
```

.pull-left[
<p align = "center">
  <img src = iris_species.jpeg>
</p>
]
.pull-right[
<p align = "center">
  <img src = iris_petal_sepal.png width = "180">
</p>  
]

---

## Exploring data, continued

```{r, out.width = "45%"}
g <- ggplot(d, aes(Sepal.Length)) + geom_histogram()
print(g)
```



---

## Data manipulation

Reshaping data is an essenstial part of data analysis. We will use a package called `dplyr`, which is a part of `tidyverse`.

```{r, eval = F}
library(dplyr) 
# you could run library(tidyverse) instead
```

`dplyr` provides the following _verbs_ that are useful in data manipulation:
- `select()`: subset using columns (variables)
- `filter()`: subset using rows (observations)
- `mutate()`: transform variables
- `arrange()`: reorder observations

These verbs, when combined with the pipe operator `%>%`, become even more powerful!

---

## Piping

For a function `f`, the expression `x %>% f(y, z)` is the same as `f(x, y, z)`.

```{r}
x.in <- c(1, 3, 6, 2, 5, 4) 
x.in %>% sum() # this is same as sum(x.in) #<<
```

```{r}
x.in %>% sort()
x.in %>% sort(decreasing = T)
```

--

Piping is even more useful when it is used as a chain.

---

## Piping, continued

**Example**: compute $\sqrt{\log 1} + \sqrt{\log 2} + \sqrt{\log 3} + \cdots + \sqrt{\log 100}$.

--

```{r}
num <- 1:100
log.num <- log(num) # log() computes the natural logarithm #<<
sqrt.log.num <- sqrt(log.num) # sqrt() computes the square root #<<
sum(sqrt.log.num)
```

--

This can be done in the following ways too:

```{r}
sum(sqrt(log(num))) # repeated application of functions
```

--

```{r}
num %>% log() %>% sqrt() %>% sum() # chain reaction!
```

---

## select()

**Example**: create a data set consisting only of `Sepal.Length` and `Sepal.Width`.

```{r}
s1 <- select(d, Sepal.Length, Sepal.Width) #<<
dim(s1)
head(s1)
```

---
 
## select(), continued

**Exercise**: create a data set consisting of `Sepal.Length`, `Sepal.Width`, `Petal.Length` and `Petal.Width`.

--

```{r}
s2 <- select(d, Sepal.Length, Sepal.Width, Petal.Length, Petal.Width)
dim(s2)
head(s2)
```

---

## select(), continued

One can specify columns to be excluded:

```{r}
s3 <- select(d, -Species) #<<
head(s3)
```

---

## filter()

**Example**: create a data set consisting only of `setosa` species.

```{r}
f1 <- filter(d, Species == "setosa") # note use of ==, not = #<<
dim(f1)
head(f1)
```

---

## filter(), continued

**Exercise**: create a data set consisting only of `setosa` and `virginica` species.

--

```{r}
f2 <- filter(d, Species %in% c("setosa", "virginica")); dim(f2)
tail(f2)
```

--

```{r}
f3 <- filter(d, Species != "versicolor"); dim(f3)
```

---

## filter(), continued

**Exercise**: create a data set with `Sepal.Length` < 6.

--

```{r}
f4 <- filter(d, Sepal.Length < 6)
dim(f4)
head(f4)
```

---

## filter(), continued

Multiple conditions can be supplied to `filter()`:

**Exercise**: how many `virginica` species have `Sepal.Length` at least 5.7?

--

```{r}
# multiple conditions (comma separated) can be used in filter()
f5 <- filter(d, Sepal.Length >= 5.7, Species == "virginica")
dim(f5)
```

---

## mutate()

**Example**: create a new variable `Sepal.Sum` which is defined as `Sepal.Length` + `Sepal.Width`.

```{r}
m1 <- mutate(d, Sepal.Sum = Sepal.Length + Sepal.Width) #<<
dim(m1)
head(m1)
```

---

## mutate(), continued

**Exercise**: create a new variable `size` which is defined as "big" if `Sepal.Length` $\geq$ 5 and "small" if `Sepal.Length` $<$ 5 (_Hint_: you might want to look up the function `ifelse()`).

--

```{r}
m2 <- mutate(d, size = ifelse(Sepal.Length >= 5, "big", "small")) #<<
dim(m2)
head(m2)
```

---

## mutate(), continued

**Exercise**: create a new variable `ID` which gives the identifier for each observation such as `obs1`, `obs2`, $\ldots$, `obs150`.

--

```{r}
m3 <- mutate(d, ID = paste0("obs", 1:nrow(d))); head(m3)
```


---

## arrange()

**Example**: sort `d` by `Sepal.Length` (ascending order)

```{r}
a1 <- arrange(d, Sepal.Length) #<<
dim(a1)
head(a1)
```

---

## arrange(), continued

**Example**: sort `d` by `Sepal.Length` (descending order) 

```{r}
a2 <- arrange(d, desc(Sepal.Length)) #<<
dim(a2)
head(a2)
```

---

## Wrap-up

**Exercise**: report all `setosa` elements with the difference `Diff` defined by `Diff` =  `Sepal.Length` - `Sepal.Width` > 1.5. Show only `Sepal.Length`, `Sepal.Width` and `Diff`, and sort by descending order of `Diff`.

--

```{r}
r1 <- mutate(d, Diff = Sepal.Length - Sepal.Width)
```

--

```{r}
r2 <- filter(r1, Diff > 1.5, Species == "setosa")
```

--

```{r}
r3 <- select(r2, Sepal.Length, Sepal.Width, Diff)
```

--

```{r}
r4 <- arrange(r3, desc(Diff)); head(r4)
```

---

## Wrap-up, continued

Piping operator `%>%` enhances readability.

```{r}
r5 <- d %>% 
  mutate(Diff = Sepal.Length - Sepal.Width) %>%
  filter(Diff > 1.5, Species == "setosa") %>%
  select(Sepal.Length, Sepal.Width, Diff) %>%
  arrange(desc(Diff))
head(r5)
```

---

## Dot(.) notation

In a chain of piping, dot(.) represents the input for the current pipe operator:

```{r}
r6 <- d %>%
  select(Species, Petal.Width) %>%
  mutate(ID = paste0("obs", 1:nrow(.))) #<<
head(r6)
```

---

## Other useful functions

- `count()`: gives a frequency table:

```{r}
d %>% count(Species) #<<
```

--

- `pull()`: extract a column (acts like `$`):

```{r}
d %>% pull(Sepal.Length) %>% head() #<<
```

---

## Other useful functions, continued

- `slice()`: exctract selected rows:

```{r}
d %>% select(Species, Petal.Width) %>%
  mutate(ID = paste0("obs", 1:nrow(.))) %>%
  slice(5:8) # rows 5 through 8 #<<
```

--

- `top_n()`: top `n` elements for a given `n` and a variable:

```{r}
d %>% top_n(3, Sepal.Width) #<<
```

---

## group_by() / summarize()

**Example**: find the mean `Sepal.Length` for each `Species`.

--

```{r}
setosa_df <- iris %>% 
  filter(Species == "setosa")
mean(setosa_df$Sepal.Length)
```

--

```{r}
versi_df <- iris %>% 
  filter(Species == "versicolor")
mean(versi_df$Sepal.Length)

virgi_df <- iris %>% 
  filter(Species == "virginica")
mean(virgi_df$Sepal.Length)
```

---

## group_by() / summarize(), continued

`group_by()` and `summarize()` combination: summary of data (e.g. mean, max, min, median) by each category of a categorical variable. 

**Example**: find the mean `Sepal.Length` for each `Species`.

```{r}
# For each 'Species' category in the 'iris' data set
# compute the mean of 'Sepal.Length'
group_by(iris, Species) %>% #<<
  summarize(mean.Sepal.Length = mean(Sepal.Length)) #<<
```

Note that the result is a data frame with two columns: `Species` and `mean.Sepal.Length`.

---

## group_by() / summarize(), continued

**Exercise**: What is the maximum (and minimum) of `Sepal.Length` in each `Species`?

--

```{r}
iris %>% group_by(Species) %>%
  summarize(max.Sepal.Length = max(Sepal.Length), # max(): maximum #<<
            min.Sepal.Length = min(Sepal.Length)) # min(): minimum #<<
```

---

## group_by() / summarize(), continued

One can get summary data using _multiple_ "group by" variables.

```{r}
diamonds %>% 
  group_by(color, cut) %>% #<<
  summarize(avg.price = mean(price), top.price = max(price)) 
```

---

## Exercise

**Exercise**: `starwars`, which comes with the package `dplyr`, is a data set that contains data related with characters in the movie Star Wars. 

- Explorer the data set. Subset the data so that the resulting data set contains only _Human_ species with `height` data available (_Hint_: look up `is.na()`). How many observations?

--

- Using the previous subset, compute the mean height for each gender. 

--

- Find the homeworld of the tallest Human male character.



