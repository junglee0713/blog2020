---
title: "Lecture 3"
author: "Jung-Jin Lee"
date: "Jan 21, 2020"
output:
  xaringan::moon_reader:
    css: ["default", "default-fonts", "Drexel.css"] 
    lib_dir: libs
    nature:
      highlightStyle: github
      highlightLines: true
      countIncrementalSlides: false
editor_options: 
  chunk_output_type: console
---
 
```{r, message = F, echo = F, warning = F}
library(tidyverse) 
library(gridExtra)
library(knitr) 
opts_chunk$set(
  tidy = FALSE,
  cache = FALSE,
  echo = TRUE,
  warning = FALSE,
  message = FALSE,
  dpi = 300,
  fig.align = "center",
  fig.width = 4,
  fig.height = 4
  )
options(width = 70) # controls console (and slide) output width
```

## Exploring data

```{r}
d <- iris # iris data set comes with base R
dim(d)
```

So `d` has `r nrow(d)` observations and `r ncol(d)` variables.

```{r}
head(d)
```

---

## Exploring data, continued

```{r}
table(d$Species)
```

.pull-left[
<p align = "center">
  <img src = iris_species.jpeg>
</p>
]
.pull-right[
<p align = "center">
  <img src = iris_petal_sepal.png width = "180">
</p>  
]

---

## Exploring data, continued

```{r, out.width = "45%"}
g <- ggplot(d, aes(Sepal.Length)) + geom_histogram()
print(g)
```

One can export a plot as a separate file:

```{r, eval = F}
ggsave(filename = "histo.pdf", g) 
```

---

## Data manipulation

Reshaping data is an essenstial part of data analysis. We will use a package called `dplyr`, which is a part of `tidyverse`.

```{r}
library(dplyr) 
# you could run library(tidyverse) instead
```

`dplyr` provides the following _verbs_ that are useful in data manipulation:
- `select()`: subset using columns (variables)
- `filter()`: subset using rows (observations)
- `mutate()`: transform variables
- `arrange()`: reorder observations

These verbs, when combined with the pipe operator `%>%`, become even more powerful!

---

## Piping

**Example**: compute $\sqrt{1} + \sqrt{2} + \sqrt{3} + \cdots + \sqrt{100}$.

```{r}
num <- 1:100
sqrt.num <- sqrt(num) # sqrt() compute the square root
sum(sqrt.num)
```

This can be done in the following way too:

```{r}
sum(sqrt(1:100)) # repeated application of functions
```

--

Piping `%>%` provides a better readability.For a function `f`, `x %>% f(y, z)` returns `f(x, y, z)`

```{r}
x.in <- c(1, 3, 6, 2, 5, 4) 
x.in %>% sum()
```

---

## Piping, continued

```{r}
x.in %>% sort()
x.in %>% sort(decreasing = T)
```

--

**Example**: compute $\sqrt{1} + \sqrt{2} + \sqrt{3} + \cdots + \sqrt{100}$.

```{r}
num %>% sqrt() %>% sum() # chain reaction!
```

```{r}
sum.value <- num %>% sqrt() %>% sum() ; print(sum.value)
 num %>% sqrt() %>% sum() -> sum.value2; print(sum.value2)
```

---

## select()

**Example**: create a data set consisting only of `Sepal.Length` and `Sepal.Width`.

```{r}
s1 <- select(d, Sepal.Length, Sepal.Width)
dim(s1)
head(s1)
```

---
 
## select(), continued

**Exercise**: create a data set consisting of `Sepal.Length`, `Sepal.Width`, `Petal.Length` and `Petal.Width`.

--

```{r}
s2 <- select(d, Sepal.Length, Sepal.Width, Petal.Length, Petal.Width)
dim(s2)
head(s2)
```

---

## select(), continued

```{r}
s3 <- select(d, -Species)
head(s3)
```

---

## filter()

**Example**: create a data set consisting only of `setosa` species.

```{r}
f1 <- filter(d, Species == "setosa") # note use of ==, not =
dim(f1)
head(f1)
```

---

## filter(), continued

**Exercise**: create a data set consisting only of `setosa` and `virginica` species.

--

```{r}
f2 <- filter(d, Species %in% c("setosa", "virginica")) # %in%
dim(f2)
tail(f2)
```

--

```{r}
f3 <- filter(d, Species != "versicolor") # != means "not equal"
dim(f3)
```

---

## filter(), continued

**Exercise**: create a data set with `Sepal.Length` < 6.

--

```{r}
f4 <- filter(d, Sepal.Length < 6); dim(f4)
head(f4)
```

--

Multiple conditions can be supplied for `filter()`:

**Exercise**: how many `virginica` species have `Sepal.Length` at least 5.7?

--

```{r}
f5 <- filter(d, Sepal.Length >= 5.7, Species == "virginica"); dim(f5)
```

---

## mutate()

**Example**: create a new variable `Sepal.Sum` which is defined as `Sepal.Length` + `Sepal.Width`.

```{r}
m1 <- mutate(d, Sepal.Sum = Sepal.Length + Sepal.Width); dim(m1)
head(m1, n = 8) # showing 8 rows using "n = 8"
```

---

## mutate(), continued

**Exercise**: create a new variable `size` which is defined as "big" if `Sepal.Length` $\geq$ 5 and "small" if `Sepal.Length` $<$ 5 (_Hint_: you might want to look up the function `ifelse()`).

--

```{r}
m2 <- mutate(d, size = ifelse(Sepal.Length >= 5, "big", "small"))
dim(m2)
head(m2)
```

---

## arrange()

**Example**: sort `d` by `Sepal.Length` (ascending order)

```{r}
a1 <- arrange(d, Sepal.Length)
dim(a1)
head(a1)
```

---

## arrange(), continued

**Example**: sort `d` by `Sepal.Length` (descending order) 

```{r}
a2 <- arrange(d, desc(Sepal.Length))
dim(a2)
head(a2)
```

---

## Wrap-up

**Exercise**: report all `setosa` elements with the difference `Diff` defined by `Diff` =  `Sepal.Length` - `Sepal.Width` > 1.5. Show only `Sepal.Length`, `Sepal.Width` and `Diff`, and sort by descending order of `Diff`.

--

```{r}
r1 <- mutate(d, Diff = Sepal.Length - Sepal.Width)
```

--

```{r}
r2 <- filter(r1, Diff > 1.5, Species == "setosa")
```

--

```{r}
r3 <- select(r2, Sepal.Length, Sepal.Width, Diff)
```

--

```{r}
r4 <- arrange(r3, desc(Diff))
head(r4)
```

---

## Wrap-up, continued

Piping operator `%>%` enhances readability.

```{r}
r <- d %>% 
  mutate(Diff = Sepal.Length - Sepal.Width) %>%
  filter(Diff > 1.5, Species == "setosa") %>%
  select(Sepal.Length, Sepal.Width, Diff) %>%
  arrange(desc(Diff))
head(r)
```

---

## group_by() / summarize()

**Exercise**: find the mean `Sepal.Length` for each `Species`.

```{r}
setosa_df <- iris %>% 
  filter(Species == "setosa")
mean(setosa_df$Sepal.Length)

versi_df <- iris %>% 
  filter(Species == "versicolor")
mean(versi_df$Sepal.Length)

virgi_df <- iris %>% 
  filter(Species == "virginica")
mean(virgi_df$Sepal.Length)
```

---

## group_by() / summarize(), continued

`group_by()` and `summarize()` combination: summary of data (e.g. mean, max, min, median) by each category of a categorical variable. 

**Exercise**: find the mean `Sepal.Length` for each `Species`.

```{r}
# For each 'Species' category in the 'iris' data set
# compute the mean of 'Sepal.Length'
group_by(iris, Species) %>%
  summarize(SL.mean = mean(Sepal.Length))
```

Note that the result is a data frame with two columns: `Species` and `SL.mean`.

---

## group_by() / summarize(), continued

**Exercise**: What is the maximum (and minimum) of `Sepal.Length` in each `Species`?

--

```{r}
iris %>% group_by(Species) %>%
  summarize(SL.max = max(Sepal.Length), SL.min= min(Sepal.Length))
```

---

## group_by() / summarize(), continued

One can get summary data using multiple "group by" variables.

```{r}
diamonds %>% 
  group_by(color, cut) %>%
  summarize(avg.price = mean(price), top.price = max(price)) 
```

---

## Wide and long form of data

Calories taken by four patients on a certain day:

```{r}
cal_wide <- data.frame(subject = paste0("Patient", 1:4),
                      breakfast = c(300, 350, 300, 250),
                      lunch = c(500, 500, 500, 450),
                      dinner = c(600, 650, 450, 500))
print(cal_wide)
```

---

## Wide and long form of data

At times, _long_ format of data is more convenient to deal with:

$$\begin{array}{c|c|c} \text{subject} & \text{meal} & \text{calorie} \\ \hline   
\text{Patient1} & \text{breakfast} & 300   \\  
\text{Patient1} & \text{lunch} & 500  \\
\text{Patient1} & \text{dinner} & 600  \\
\text{Patient2} & \text{breakfast} & 350   \\  
\text{Patient2} & \text{lunch} & 500  \\
\text{Patient2} & \text{dinner} & 650  \\
\vdots & \vdots & \vdots
\end{array}$$

---

## Wide and long form of data

`pivot_longer()` transforms wide format into long format:

```{r}
cal_long <- cal_wide %>%
  pivot_longer(cols = c("breakfast", "lunch", "dinner"), 
               names_to = "meal", 
               values_to = "calorie") %>%
  arrange(subject)
head(cal_long)
```

---

## Wide and long form of data

`pivot_longer()` can be used in a way excluding column(s) not to be transformed:

```{r}
cal_long_2 <- cal_wide %>%
  pivot_longer(cols = -c("subject"), # note the use of -
               names_to = "meal", 
               values_to = "calorie") %>%
  arrange(subject)
head(cal_long_2)
```

---

## Wide and long form of data

`pivot_wider()` transforms long format to wide format:

```{r}
cal_wide_2 <- cal_long %>%
  pivot_wider(names_from = "meal", values_from = "calorie")

head(cal_wide_2)
```

---

## Box plot

**Example**: describe the distribution of `Sepal.Length` using box plot.

```{r, out.width = "50%"}
g <- ggplot(d, aes(x = Species, y = Sepal.Length)) +
  geom_boxplot()
print(g)
```

---

## Box plot, continued

- The thick line indicates the median.
- The lower and upper hinges correspond to the 25% and 75% quantiles. 
- The upper whisker extends from the hinge to the largest value no further than 1.5 $\times$ IQR from the hinge, where IQR is the inter-quartile range (distance between the 25% and 75% quantiles). Similarly for the lower whisker. 

--

**Exercise**: compute the maximum, minimum, 25% quantile, 75% quantile and median for `versicola` species and compare with the previous plot. 

--

```{r}
ds <- d %>%
  filter(Species == "versicolor")
quantile(ds$Sepal.Length)
```

---

## Box plot, continued

**Exercise**: create the following plots.

```{r, echo = F, out.width = "50%"}
g <- d %>%
  filter(Species != "versicolor") %>%
  ggplot(aes(Species, Sepal.Width)) +
  geom_boxplot()
print(g)
```

---

## Scatter plots

How are `Sepal.Length` and `Sepal.Width` associated?

--

```{r, out.width = "50%"}
g <- ggplot(d, aes(x = Sepal.Length, y = Sepal.Width)) +
  geom_point()
print(g)
```

---

## Scatter plots, continued

```{r, out.width = "50%"}
g <- ggplot(d, aes(Sepal.Length, Sepal.Width, color = Species)) +
  geom_point()
print(g)
```

---

## Scatter plots, continued

```{r, out.width = "60%"}
g2 <- g + theme(aspect.ratio = 1) +
  ggtitle("A better shape") # additional features can be added
print(g2)
```
